Codebase Analysis for: .

Directory Structure:
└── .
    ├── .env
    ├── md
    │   ├── index.md
    │   └── test.md
    ├── package.json
    ├── public
    │   ├── index.html
    │   └── test.html
    ├── src
    │   └── index.ts
    └── tsconfig.json

Summary:
Total files analyzed: 8
Total directories analyzed: 3
Estimated output size: 22.64 KB
Actual analyzed size: 20.88 KB
Total tokens: 5700
Actual text content size: 20.38 KB

File Contents:

==================================================
File: .\.env
==================================================
NODE_TLS_REJECT_UNAUTHORIZED=0

==================================================
File: .\md\index.md
==================================================


==================================================
File: .\md\test.md
==================================================
# hello

==================================================
File: .\package.json
==================================================
{
  "name": "md-localify",
  "version": "1.0.0",
  "description": "",
  "main": "index.ts",
  "scripts": {
    "build": "tsx ./src/index.ts build",
    "start": "node ./build/index.js",
    "dev": "tsx watch --env-file=.env --include=\"./*\" ./src/index.ts dev"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "module",
  "devDependencies": {
    "@types/node": "^24.9.2",
    "@types/sanitize-html": "^2.16.0",
    "eslint": "^9.38.0",
    "prettier": "^3.6.2",
    "ts-node": "^10.9.2",
    "tsx": "^4.20.6",
    "typescript": "^5.9.3"
  },
  "dependencies": {
    "@types/express": "^5.0.5",
    "express": "^5.1.0",
    "sanitize-html": "^2.17.0"
  }
}


==================================================
File: .\public\index.html
==================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Home</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; line-height: 1.6; margin: 0; color: #333; }
        .container { display: flex; min-height: 100vh; }
        .sidebar { width: 220px; min-width: 220px; border-right: 1px solid #e0e0e0; padding: 2em; background-color: #f9f9f9; }
        .sidebar h2 { font-size: 1.1em; margin-top: 0; margin-bottom: 1em; color: #555; text-transform: uppercase; letter-spacing: 0.5px; }
        .sidebar ul { list-style: none; padding: 0; margin: 0; }
        .sidebar ul ul { padding-left: 1em; border-left: 1px solid #eee; margin-left: 0.2em; margin-top: 0.5em;}
        .sidebar li { margin-bottom: 0.5em; }
        .sidebar a { color: #333; text-decoration: none; display: block; padding: 0.2em 0; border-radius: 4px; transition: background-color 0.2s, color 0.2s; }
        .sidebar a:hover { color: #007bff; }
        .sidebar a.active { font-weight: bold; color: #007bff; }
        main { flex-grow: 1; padding: 2em 3em; max-width: 800px; }
        main img { max-width: 100%; height: auto; border-radius: 4px; }
        h1, h2, h3 { line-height: 1.2; }
        pre { background: #f4f4f4; padding: 1em; border-radius: 5px; overflow-x: auto; border: 1px solid #ddd; }
        code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
        a { color: #007bff; text-decoration: none; }
        a:hover { text-decoration: underline; }
        p { margin-bottom: 1em; }
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <h2>Navigation</h2>
            <ul><li><a href="/index.html" class="active">Home</a></li><li><a href="/test.html" class="">Test</a></li></ul>
        </aside>
        <main>

        </main>
    </div>
    
    <script>
        const evtSource = new EventSource("/__livereload__");
        evtSource.onmessage = function(event) {
            if (event.data === 'reload') {
                console.log('Reloading page...');
                window.location.reload();
            }
        };
        evtSource.onerror = function() {
            console.log("Live reload connection error. Retrying...");
        };
    </script>
    
</body>
</html>

==================================================
File: .\public\test.html
==================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; line-height: 1.6; margin: 0; color: #333; }
        .container { display: flex; min-height: 100vh; }
        .sidebar { width: 220px; min-width: 220px; border-right: 1px solid #e0e0e0; padding: 2em; background-color: #f9f9f9; }
        .sidebar h2 { font-size: 1.1em; margin-top: 0; margin-bottom: 1em; color: #555; text-transform: uppercase; letter-spacing: 0.5px; }
        .sidebar ul { list-style: none; padding: 0; margin: 0; }
        .sidebar ul ul { padding-left: 1em; border-left: 1px solid #eee; margin-left: 0.2em; margin-top: 0.5em;}
        .sidebar li { margin-bottom: 0.5em; }
        .sidebar a { color: #333; text-decoration: none; display: block; padding: 0.2em 0; border-radius: 4px; transition: background-color 0.2s, color 0.2s; }
        .sidebar a:hover { color: #007bff; }
        .sidebar a.active { font-weight: bold; color: #007bff; }
        main { flex-grow: 1; padding: 2em 3em; max-width: 800px; }
        main img { max-width: 100%; height: auto; border-radius: 4px; }
        h1, h2, h3 { line-height: 1.2; }
        pre { background: #f4f4f4; padding: 1em; border-radius: 5px; overflow-x: auto; border: 1px solid #ddd; }
        code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
        a { color: #007bff; text-decoration: none; }
        a:hover { text-decoration: underline; }
        p { margin-bottom: 1em; }
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <h2>Navigation</h2>
            <ul><li><a href="/index.html" class="">Home</a></li><li><a href="/test.html" class="active">Test</a></li></ul>
        </aside>
        <main>
<h1>hello</h1>
        </main>
    </div>
    
    <script>
        const evtSource = new EventSource("/__livereload__");
        evtSource.onmessage = function(event) {
            if (event.data === 'reload') {
                console.log('Reloading page...');
                window.location.reload();
            }
        };
        evtSource.onerror = function() {
            console.log("Live reload connection error. Retrying...");
        };
    </script>
    
</body>
</html>

==================================================
File: .\src\index.ts
==================================================
// src/index.ts
import * as fs from "fs";
import * as path from "path";
import * as http from "http";
import sanitizeHtml from "sanitize-html";

const mdDir = path.join(process.cwd(), "md");
const publicDir = path.join(process.cwd(), "public");
const imageDir = publicDir;
const PORT = 3000;

let allUsedImages: Set<string>;

interface NavItem {
  name: string;
  path: string;
  children?: NavItem[];
}

const prettifyName = (name: string): string => {
  const baseName = path.basename(name, ".md");
  if (baseName === "index") return "Home";
  return baseName.replace(/-/g, " ").replace(/\b\w/g, (l) => l.toUpperCase());
};

const buildNavTree = (dir: string, webPathPrefix: string): NavItem[] => {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  const navItems: NavItem[] = [];

  const files = entries.filter((e) => e.isFile() && e.name.endsWith(".md"));
  const dirs = entries.filter((e) => e.isDirectory());

  files.sort((a, b) => {
    if (a.name === "index.md") return -1;
    if (b.name === "index.md") return 1;
    return a.name.localeCompare(b.name);
  });
  dirs.sort((a, b) => a.name.localeCompare(b.name));

  for (const file of files) {
    navItems.push({
      name: prettifyName(file.name),
      path: `${webPathPrefix}${file.name.replace(/\.md$/, ".html")}`,
    });
  }

  for (const subDir of dirs) {
    const children = buildNavTree(
      path.join(dir, subDir.name),
      `${webPathPrefix}${subDir.name}/`
    );
    if (children.length > 0) {
      const indexPage = children.find(
        (child) => path.basename(child.path) === "index.html"
      );
      navItems.push({
        name: prettifyName(subDir.name),
        path: indexPage ? indexPage.path : "#",
        children: children,
      });
    }
  }

  return navItems;
};

const generateSidebarHtml = (
  navTree: NavItem[],
  currentPagePath: string
): string => {
  let html = "<ul>";
  for (const item of navTree) {
    const isActive = item.path === currentPagePath;
    html += `<li><a href="${item.path}" class="${isActive ? "active" : ""}">${item.name}</a>`;
    if (item.children && item.children.length > 0) {
      html += generateSidebarHtml(item.children, currentPagePath);
    }
    html += "</li>";
  }
  html += "</ul>";
  return html;
};

const processMarkdownImages = async (
  markdown: string,
  withLiveReload: boolean
): Promise<string> => {
  const imageUrlRegex = /!\[(.*?)\]\((https?:\/\/.*?)\)/g;
  const matches = [...markdown.matchAll(imageUrlRegex)];
  let processedMarkdown = markdown;

  for (const match of matches) {
    const fullMatch = match[0];
    const altText = match[1];
    const remoteUrl = match[2];

    if (!remoteUrl) continue;

    try {
      const url = new URL(remoteUrl);
      const filename = path.basename(url.pathname);
      const localFilePath = path.join(imageDir, filename);

      allUsedImages.add(localFilePath);

      if (!fs.existsSync(localFilePath)) {
        console.log(`- Downloading image: ${remoteUrl}`);
        const response = await fetch(remoteUrl);
        if (!response.ok) {
          throw new Error(
            `Failed to fetch ${remoteUrl}: ${response.statusText}`
          );
        }
        const buffer = await response.arrayBuffer();
        fs.writeFileSync(localFilePath, Buffer.from(buffer));
        console.log(
          `  -> Saved to: ${path.relative(process.cwd(), localFilePath)}`
        );
      }

      const webPath = withLiveReload
        ? `http://localhost:${PORT}/${filename}`
        : `/${filename}`;
      const newImageTag = `![${altText}](${webPath})`;
      processedMarkdown = processedMarkdown.replace(fullMatch, newImageTag);
    } catch (error) {
      console.error(`Error processing image ${remoteUrl}:`, error);
    }
  }

  return processedMarkdown;
};

const parseMarkdown = (markdown: string): string => {
  const blocks = sanitizeHtml(markdown)
    .split("\n\n")
    .filter((block) => block.trim() !== "");

  const htmlBlocks = blocks.map((block) => {
    if (block.startsWith("### ")) return `<h3>${block.substring(4)}</h3>`;
    if (block.startsWith("## ")) return `<h2>${block.substring(3)}</h2>`;
    if (block.startsWith("# ")) return `<h1>${block.substring(2)}</h1>`;

    if (block.startsWith("```")) {
      const lines = block.split("\n");
      const code = lines.slice(1, lines.length - 1).join("\n");
      const escapedCode = code
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
      return `<pre><code>${escapedCode}</code></pre>`;
    }
    return `<p>${block}</p>`;
  });

  let html = htmlBlocks.join("\n");

  html = html.replace(/!\[(.*?)\]\((.*?)\)/g, '<img src="$2" alt="$1">');
  html = html.replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2">$1</a>');
  html = html.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/\*(.*?)\*/g, "<em>$1</em>");
  html = html.replace(
    /<p>(.*?)<\/p>/gs,
    (match, content) => `<p>${content.replace(/\n/g, "<br>")}</p>`
  );

  return html;
};

const createHtmlTemplate = (
  title: string,
  content: string,
  sidebarHtml: string,
  withLiveReload: boolean = false
): string => `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; line-height: 1.6; margin: 0; color: #333; }
        .container { display: flex; min-height: 100vh; }
        .sidebar { width: 220px; min-width: 220px; border-right: 1px solid #e0e0e0; padding: 2em; background-color: #f9f9f9; }
        .sidebar h2 { font-size: 1.1em; margin-top: 0; margin-bottom: 1em; color: #555; text-transform: uppercase; letter-spacing: 0.5px; }
        .sidebar ul { list-style: none; padding: 0; margin: 0; }
        .sidebar ul ul { padding-left: 1em; border-left: 1px solid #eee; margin-left: 0.2em; margin-top: 0.5em;}
        .sidebar li { margin-bottom: 0.5em; }
        .sidebar a { color: #333; text-decoration: none; display: block; padding: 0.2em 0; border-radius: 4px; transition: background-color 0.2s, color 0.2s; }
        .sidebar a:hover { color: #007bff; }
        .sidebar a.active { font-weight: bold; color: #007bff; }
        main { flex-grow: 1; padding: 2em 3em; max-width: 800px; }
        main img { max-width: 100%; height: auto; border-radius: 4px; }
        h1, h2, h3 { line-height: 1.2; }
        pre { background: #f4f4f4; padding: 1em; border-radius: 5px; overflow-x: auto; border: 1px solid #ddd; }
        code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
        a { color: #007bff; text-decoration: none; }
        a:hover { text-decoration: underline; }
        p { margin-bottom: 1em; }
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <h2>Navigation</h2>
            ${sidebarHtml}
        </aside>
        <main>
${content}
        </main>
    </div>
    ${
      withLiveReload
        ? `
    <script>
        const evtSource = new EventSource("/__livereload__");
        evtSource.onmessage = function(event) {
            if (event.data === 'reload') {
                console.log('Reloading page...');
                window.location.reload();
            }
        };
        evtSource.onerror = function() {
            console.log("Live reload connection error. Retrying...");
        };
    </script>
    `
        : ""
    }
</body>
</html>`;

const cleanupOrphanedImages = () => {
  console.log("Cleaning up orphaned images...");
  if (!fs.existsSync(imageDir)) return;

  const imageExtensions = [".png", ".jpg", ".jpeg", ".gif", ".svg", ".webp"];
  const filesInDir = fs.readdirSync(imageDir);

  for (const file of filesInDir) {
    const fullPath = path.join(imageDir, file);
    if (imageExtensions.includes(path.extname(file).toLowerCase())) {
      if (!allUsedImages.has(fullPath)) {
        console.log(
          `- Deleting orphaned image: ${path.relative(process.cwd(), fullPath)}`
        );
        fs.unlinkSync(fullPath);
      }
    }
  }
  console.log("Cleanup complete.");
};

const compile = async (withLiveReload: boolean = false) => {
  console.log("Building static pages...");
  allUsedImages = new Set<string>();

  if (!fs.existsSync(mdDir)) {
    console.log(
      "-> No 'md' directory found. Creating one with an example file."
    );
    fs.mkdirSync(mdDir, { recursive: true });
    fs.writeFileSync(
      path.join(mdDir, "index.md"),
      "# Hello World\n\nThis is your first page.\n\nEdit `md/index.md` to see changes."
    );
  }

  if (fs.existsSync(publicDir) && !withLiveReload) {
    fs.rmSync(publicDir, { recursive: true, force: true });
  }
  fs.mkdirSync(publicDir, { recursive: true });

  const navTree = buildNavTree(mdDir, "/");

  const processFiles = async (
    dir: string,
    outBaseDir: string,
    webPathPrefix: string
  ) => {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        const newOutDir = path.join(outBaseDir, entry.name);
        fs.mkdirSync(newOutDir, { recursive: true });
        await processFiles(
          fullPath,
          newOutDir,
          `${webPathPrefix}${entry.name}/`
        );
      } else if (entry.isFile() && entry.name.endsWith(".md")) {
        let markdownContent = fs.readFileSync(fullPath, "utf-8");
        markdownContent = await processMarkdownImages(
          markdownContent,
          withLiveReload
        );

        const htmlContent = parseMarkdown(markdownContent);
        const title = prettifyName(entry.name);

        const outFileName = entry.name.replace(/\.md$/, ".html");
        const currentPagePath = `${webPathPrefix}${outFileName}`;

        const sidebarHtml = generateSidebarHtml(navTree, currentPagePath);
        const finalHtml = createHtmlTemplate(
          title,
          htmlContent,
          sidebarHtml,
          withLiveReload
        );

        const outFilePath = path.join(outBaseDir, outFileName);
        fs.writeFileSync(outFilePath, finalHtml);
        console.log(
          `- Generated: ${path.relative(process.cwd(), outFilePath)}`
        );
      }
    }
  };

  await processFiles(mdDir, publicDir, "/");
  cleanupOrphanedImages();
  console.log("Build complete!");
};

let liveReloadClients: http.ServerResponse[] = [];

const triggerReload = () => {
  for (const res of liveReloadClients) {
    if (!res.writableEnded) {
      res.write("data: reload\n\n");
    }
  }
};

const debounce = <F extends (...args: any[]) => any>(
  func: F,
  waitFor: number
) => {
  let timeout: NodeJS.Timeout;
  return (...args: Parameters<F>): Promise<ReturnType<F>> =>
    new Promise((resolve) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => resolve(func(...args)), waitFor);
    });
};

const handleRebuild = debounce(async () => {
  console.log("\nChanges detected, rebuilding...");
  try {
    await compile(true);
    triggerReload();
  } catch (error) {
    console.error("Build failed:", error);
  }
}, 100);

const startDevServer = () => {
  const server = http.createServer((req, res) => {
    const url = req.url || "/";
    if (url === "/__livereload__") {
      res.writeHead(200, {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
      });
      liveReloadClients.push(res);
      req.on("close", () => {
        liveReloadClients = liveReloadClients.filter(
          (client) => client !== res
        );
      });
      return;
    }

    let filePath = path.join(publicDir, url);
    if (fs.existsSync(filePath) && fs.statSync(filePath).isDirectory()) {
      filePath = path.join(filePath, "index.html");
    }

    const ext = path.extname(filePath);
    const contentTypes: { [key: string]: string } = {
      ".html": "text/html",
      ".css": "text/css",
      ".js": "application/javascript",
      ".png": "image/png",
      ".jpg": "image/jpeg",
      ".jpeg": "image/jpeg",
      ".gif": "image/gif",
      ".svg": "image/svg+xml",
      ".webp": "image/webp",
    };
    const contentType = contentTypes[ext] || "application/octet-stream";

    fs.readFile(filePath, (err, content) => {
      if (err) {
        res.writeHead(404, { "Content-Type": "text/plain" });
        res.end("404 Not Found");
      } else {
        res.writeHead(200, { "Content-Type": contentType });
        res.end(content);
      }
    });
  });

  server
    .listen(PORT, () => {
      console.log(`\nDevelopment server running at http://localhost:${PORT}`);
      console.log("Watching for changes in ./md...");
    })
    .on("error", (err: NodeJS.ErrnoException) => {
      if (err.code === "EADDRINUSE") {
        console.error(`Error: Port ${PORT} is already in use.`);
        process.exit(1);
      } else {
        console.error(err);
      }
    });
};

const watchFiles = () => {
  if (!fs.existsSync(mdDir)) return;
  fs.watch(mdDir, { recursive: true }, (eventType, filename) => {
    if (filename) {
      handleRebuild();
    }
  });
};

const runDev = async () => {
  await compile(true);
  startDevServer();
  watchFiles();
};

const runBuild = async () => {
  await compile(false);
};

const main = () => {
  const command = process.argv[2];

  if (command === "dev") {
    runDev().catch((err) => {
      console.error(err);
      process.exit(1);
    });
  } else if (command === "build") {
    runBuild().catch((err) => {
      console.error(err);
      process.exit(1);
    });
  } else {
    console.log("Usage:");
    console.log("  npm run dev    - Start dev server with live reload");
    console.log("  npm run build  - Build static pages for production");
  }
};

main();

==================================================
File: .\tsconfig.json
==================================================
{
  // Visit https://aka.ms/tsconfig to read more about this file
  "compilerOptions": {
    // File Layout
    // "rootDir": "./src",
    // "outDir": "./dist",

    // Environment Settings
    // See also https://aka.ms/tsconfig/module
    "module": "nodenext",
    "target": "esnext",
    "types": ["node"],

    // For nodejs:
    // "lib": ["esnext"],
    // "types": ["node"],
    // and npm install -D @types/node

    // Other Outputs
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,

    // Stricter Typechecking Options
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,

    // Style Options
    // "noImplicitReturns": true,
    // "noImplicitOverride": true,
    // "noUnusedLocals": true,
    // "noUnusedParameters": true,
    // "noFallthroughCasesInSwitch": true,
    // "noPropertyAccessFromIndexSignature": true,

    // Recommended Options
    "strict": true,
    "jsx": "react-jsx",
    "verbatimModuleSyntax": true,
    "isolatedModules": true,
    "noUncheckedSideEffectImports": true,
    "moduleDetection": "force",
    "skipLibCheck": true,
    "outDir": "./build",
    "rootDir": "./src"
  },
  "ts-node": {
    "esm": true
  }
}

